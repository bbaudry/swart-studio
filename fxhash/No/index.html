<!DOCTYPE html>
<html lang="en">

<head>
  <script src="./p5.js"></script>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <script id="fxhash-snippet">
    //---- do not edit the following code (you can indent as you wish)
    let alphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    var fxhash = "oo" + Array(49).fill(0).map(_ => alphabet[(Math.random() * alphabet.length) | 0]).join('')
    let b58dec = str => [...str].reduce((p, c) => p * alphabet.length + alphabet.indexOf(c) | 0, 0)
    let fxhashTrunc = fxhash.slice(2)
    let regex = new RegExp(".{" + ((fxhashTrunc.length / 4) | 0) + "}", 'g')
    let hashes = fxhashTrunc.match(regex).map(h => b58dec(h))
    let sfc32 = (a, b, c, d) => {
      return () => {
        a |= 0; b |= 0; c |= 0; d |= 0
        var t = (a + b | 0) + d | 0
        d = d + 1 | 0
        a = b ^ b >>> 9
        b = c + (c << 3) | 0
        c = c << 21 | c >>> 11
        c = c + t | 0
        return (t >>> 0) / 4294967296
      }
    }
    var fxrand = sfc32(...hashes)
    // true if preview mode active, false otherwise
    // you can append preview=1 to the URL to simulate preview active
    var isFxpreview = new URLSearchParams(window.location.search).get('preview') === "1"
    // call this method to trigger the preview
    function fxpreview() {
      console.log("fxhash: TRIGGER PREVIEW")
    }
        //---- /do not edit the following code
  </script>
</head>

<body>
  <script>
    var w = 800;//document.documentElement.clientWidth;//width of window that is available for drawing
    var h = 800;//document.documentElement.clientHeight;//width of window that is available for drawing
    var bowie;
    var pts;
    var x3
    var x4
    var y3
    var y4
    var angle
    var letter

    function preload() {
      //bowie=loadFont("./fonts/FreeMono.ttf");
      bowie = loadFont("./fonts/Dyuthi-Regular.ttf");

    }

    function setup() {
      createCanvas(w, h);
      colorMode(HSB, 360, 100, 100, 250);
      background(0, 0, 0);
      textFont(bowie);
      frameRate(1)
      window.$fxhashFeatures = {
      }
    }

    function draw() {
      background(0, 0, 0);
      strokeWeight(fxrand() * 0.42 + 0.42);
      //back_with_triangles()
      //back_with_quads()
      fill(0,0,100);
      arc(w/2,h/2,w,w,PI,2*PI);
      back_with_circles(w/4,h/2,w/2,w/2);
      back_with_circles(3*w/4,h/2,w/2,w/2);

      //draw_letter_triangle("N",10)
      //draw_letter_triangle("O",360)
      draw_letter_circles("N",10)
      draw_letter_circles("O",360)

     // if (frameCount==11){save("no_with_back.png")}
      if (frameCount == 378) {
        fxpreview();
      }
    }

    function draw_letter_circles(letter,xtxt) {
      let density = 0.02;//fxrand() * 0.03 + 0.08;
      pts = bowie.textToPoints(letter, xtxt, 0.7 * h, 555, {
        sampleFactor: density,
        simplifyThreshold: 0
      })
      for (let i = 1; i < pts.length - 1; i++) {
        let p1 = pts[i];
        //let p2 = pts[i + 1]
        if (fxrand()<0.5){fill(0,0,100);}
        else {fill(0,0,0);}
        noStroke();
//        noFill();stroke(50,100,100);
        ellipse(p1.x,p1.y,84,84);
      }
    }

    function draw_letter_triangle(letter,xtxt) {
      let density = fxrand() * 0.03 + 0.08;
      pts = bowie.textToPoints(letter, xtxt, 0.7 * h, 555, {
        sampleFactor: density,
        simplifyThreshold: 0
      })
      let offangle = PI / 2;;
      let rad = 49;
      if (pts.length > 1) {
        angle = atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x) + offangle;
        x3 = pts[0].x + (pts[1].x - pts[0].x) + rad * cos(angle)
        y3 = pts[0].y + (pts[1].y - pts[0].y) + rad * sin(angle)
      }
      for (let i = 1; i < pts.length - 1; i++) {
        let p1 = pts[i];
        let p2 = pts[i + 1]
        triangle_inwards_letter(letter, p1, p2, offangle, rad)
      }
    }

    function triangle_inwards_letter(letter, p1, p2, offangle, rad) {
      fill(0, 0, 0);
      stroke(0, 0, 100);

      let vera = (-2 * fxrand() + 1) * PI / 4 ; //[-PI/4,PI/4]
      angle = atan2(p2.y - p1.y, p2.x - p1.x) + offangle + vera;
      x4 = p1.x + (p2.x - p1.x) + rad * cos(angle);
      y4 = p1.y + (p2.y - p1.y) + rad * sin(angle);
      triangle(p2.x, p2.y, x3, y3, x4, y4);
      x3 = x4;
      y3 = y4;
    }

    function back_with_circles(cx,cy,rad) {
      if (cx>w/10 || cx<w-w/10){
        if (fxrand()<0.5) {
          if (fxrand()<0.5) {fill(0,0,100)}
          else {fill(0,0,0)}
          arc(cx,cy,rad,rad,0,PI);
        }
        else {
          back_with_circles(cx/2,cy,rad/2,rad/2);
          back_with_circles(cx+cx/2,cy,rad/2,rad/2)
        }
      }
    }

    function back_with_quads() {
      let padding = w/10;
      let x1=0;
      let y1=0;
      let f=17;
      while (y1<h){
        while (x1<w){
          if (fxrand()<0.05){stroke(0,100,100);}
          else{noStroke();}
          if (fxrand()<0.5){      fill(0,0,100);}
          else{      fill(0,0,0);}
          rect(x1+fxrand()*f,y1+fxrand()*f,padding+fxrand()*f,padding+fxrand()*f)
          x1+=padding;
        }
        x1=0;
        y1+=padding;
      }
    }

    function back_with_triangles() {
      let pad_min = 11;
      let pad_max = 17;
      let i = 0;
      let top_left_x, top_right_x, bottom_x, top_left_y, top_right_y, bottom_y;
      let prev_row = [];
      let tmp_row = [];
      fill(0,0,100);
      stroke(0, 0, 0);
      strokeWeight(0.84);
      top_left_x = 0; top_left_y = 0; top_right_y = 0;
      //start with one rwo of triangles, top edge on y=0, points down, coord of bottom vertex random and saved in prev_row
      while (top_left_x < w) {
        let x = pad_max;// (pad_min + fxrand() * pad_max);
        top_right_x = top_left_x + x;
        bottom_x = top_left_x+fxrand()*(top_right_x - top_left_x);
        bottom_y = top_left_y + (pad_min + fxrand() * pad_max);
        triangle(top_left_x, top_left_y, top_right_x, top_right_y, bottom_x, bottom_y);
        top_left_x = top_right_x;
        prev_row.push([bottom_x, bottom_y]);
        i++;
      }
      //double loop to fill all rows until bottom of frame
      //for each row, reuse the vertices stored in previous row and generate coord of bottom vertices randomly, save in tmp_row
      //once a row is finished, pass tmp_row as prev_row and empty tmp_row
      while (bottom_y < h) {
        i=0;
        top_left_x = 0;
        top_left_y = prev_row[0][1]; 
        while (i < prev_row.length) {
          top_right_x = prev_row[i][0];
          top_right_y = prev_row[i][1]; 
          let x = (pad_min + 0.5 * pad_max);
          bottom_x = top_left_x+fxrand()*(top_right_x - top_left_x);
          bottom_y = top_left_y + (pad_min + fxrand() * pad_max);
          if (fxrand()<0.05){      fill(0,100,100);}
          else {      fill(0,0,100);}
          triangle(top_left_x, top_left_y, top_right_x, top_right_y, bottom_x, bottom_y);
          top_left_x = top_right_x;
          top_left_y = top_right_y;
          tmp_row.push([bottom_x, bottom_y]);
          i++;
        }
        let x = pad_max;
        triangle(top_left_x, top_left_y, top_left_x+x, top_right_y, (top_left_x+x - 0.5 * x), bottom_y);
        tmp_row.push([(top_left_x+x - 0.5 * x), bottom_y])
        prev_row=tmp_row;
        tmp_row=[];
      }
    }

    function windowResized() {
      w = document.documentElement.clientWidth;//width of window that is available for drawing
      h = document.documentElement.clientHeight;//width of window that is available for drawing
      resizeCanvas(windowWidth, windowHeight);
    }

  </script>

</body>